/*! by @vlucendo -- http://vlucendo.com */
!function(l){function n(n){for(var e,t,i=n[0],o=n[1],r=n[2],a=0,s=[];a<i.length;a++)t=i[a],u[t]&&s.push(u[t][0]),u[t]=0;for(e in o)Object.prototype.hasOwnProperty.call(o,e)&&(l[e]=o[e]);for(f&&f(n);s.length;)s.shift()();return m.push.apply(m,r||[]),c()}function c(){for(var n,e=0;e<m.length;e++){for(var t=m[e],i=!0,o=1;o<t.length;o++){var r=t[o];0!==u[r]&&(i=!1)}i&&(m.splice(e--,1),n=a(a.s=t[0]))}return n}var t={},u={0:0},m=[];function a(n){if(t[n])return t[n].exports;var e=t[n]={i:n,l:!1,exports:{}};return l[n].call(e.exports,e,e.exports,a),e.l=!0,e.exports}a.m=l,a.c=t,a.d=function(n,e,t){a.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},a.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},a.t=function(e,n){if(1&n&&(e=a(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(a.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var i in e)a.d(t,i,function(n){return e[n]}.bind(null,i));return t},a.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return a.d(e,"a",e),e},a.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},a.p="";var e=window.webpackJsonp=window.webpackJsonp||[],i=e.push.bind(e);e.push=n,e=e.slice();for(var o=0;o<e.length;o++)n(e[o]);var f=i;m.push([41,1]),c()}({17:function(n,e){n.exports=function(n){return'<canvas></canvas>\x3c!--<div class="info"></div>--\x3e'}},20:function(n,e){n.exports="precision highp float;\nprecision highp int;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\n\nuniform sampler2D tInitial;\nuniform sampler2D tLifes;\nuniform sampler2D tPositions;\nuniform float linesLazy;\nuniform float time;\nuniform float emitterRadius;\nuniform float emitterPulse;\nuniform float emitterPulseSpeed;\n\nuniform float speed;\nuniform float distanceAttraction;\nuniform float curlSize;\nuniform float curlTime;\nuniform float basePersistence;\nuniform float dyingPersistence;\n\nvarying vec2 vUv;\n\nconst int OCTAVES = 3;\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat mod289(float x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip) {\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n    return p;\n}\n\n#define F4 0.309016994374947451\n\nvec4 simplexNoiseDerivatives (vec4 v) {\n    const vec4  C = vec4( 0.138196601125011,0.276393202250021,0.414589803375032,-0.447213595499958);\n\n    vec4 i  = floor(v + dot(v, vec4(F4)) );\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    i = mod289(i);\n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n    vec3 values0 = vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2)); //value of contributions from each corner at point\n    vec2 values1 = vec2(dot(p3, x3), dot(p4, x4));\n\n    vec3 m0 = max(0.5 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0); //(0.5 - x^2) where x is the distance\n    vec2 m1 = max(0.5 - vec2(dot(x3,x3), dot(x4,x4)), 0.0);\n\n    vec3 temp0 = -6.0 * m0 * m0 * values0;\n    vec2 temp1 = -6.0 * m1 * m1 * values1;\n\n    vec3 mmm0 = m0 * m0 * m0;\n    vec2 mmm1 = m1 * m1 * m1;\n\n    float dx = temp0[0] * x0.x + temp0[1] * x1.x + temp0[2] * x2.x + temp1[0] * x3.x + temp1[1] * x4.x + mmm0[0] * p0.x + mmm0[1] * p1.x + mmm0[2] * p2.x + mmm1[0] * p3.x + mmm1[1] * p4.x;\n    float dy = temp0[0] * x0.y + temp0[1] * x1.y + temp0[2] * x2.y + temp1[0] * x3.y + temp1[1] * x4.y + mmm0[0] * p0.y + mmm0[1] * p1.y + mmm0[2] * p2.y + mmm1[0] * p3.y + mmm1[1] * p4.y;\n    float dz = temp0[0] * x0.z + temp0[1] * x1.z + temp0[2] * x2.z + temp1[0] * x3.z + temp1[1] * x4.z + mmm0[0] * p0.z + mmm0[1] * p1.z + mmm0[2] * p2.z + mmm1[0] * p3.z + mmm1[1] * p4.z;\n    float dw = temp0[0] * x0.w + temp0[1] * x1.w + temp0[2] * x2.w + temp1[0] * x3.w + temp1[1] * x4.w + mmm0[0] * p0.w + mmm0[1] * p1.w + mmm0[2] * p2.w + mmm1[0] * p3.w + mmm1[1] * p4.w;\n\n    return vec4(dx, dy, dz, dw) * 49.0;\n}\n\nvec3 curl(in vec3 p, in float noiseTime, in float persistence)\n{\n    vec4 xNoisePotentialDerivatives = vec4(0.0);\n    vec4 yNoisePotentialDerivatives = vec4(0.0);\n    vec4 zNoisePotentialDerivatives = vec4(0.0);\n\n    for(int i = 0; i < OCTAVES; ++i)\n    {\n        float twoPowI = pow(2.0, float(i));\n        float scale = 0.5 * twoPowI * pow(persistence, float(i));\n\n        /*\n        //https://github.com/dli/flow/blob/master/flow.js\n        //don't do this, persistence !== 0.0\n        float noiseScale = pow(persistence, float(i));\n        if(persistence == 0.0 && i == 0) { //fix undefined behaviour\n            'noiseScale = 1.0;\n        }\n        */\n\n        xNoisePotentialDerivatives += simplexNoiseDerivatives(vec4(p * twoPowI, noiseTime)) * scale;\n        yNoisePotentialDerivatives += simplexNoiseDerivatives(vec4((p + vec3(123.4, 129845.6, -1239.1)) * twoPowI, noiseTime)) * scale;\n        zNoisePotentialDerivatives += simplexNoiseDerivatives(vec4((p + vec3(-9519.0, 9051.0, -123.0)) * twoPowI, noiseTime)) * scale;\n    }\n\n    return vec3(\n    zNoisePotentialDerivatives[1] - yNoisePotentialDerivatives[2], xNoisePotentialDerivatives[2] - zNoisePotentialDerivatives[0], yNoisePotentialDerivatives[0] - xNoisePotentialDerivatives[1]\n    );\n}\n\nvoid main()\n{\n    float stepX = 1.0 / resolution.x;\n\n    float life = texture2D(tLifes, vec2(0.0, vUv.y)).w;\n    vec4 p = texture2D(tPositions, vUv);\n\n    vec3 currentPosition = p.xyz;\n\n    if(life == 1.0)\n    {\n        vec4 initial = texture2D(tInitial, vUv);\n        currentPosition = initial.xyz;\n        currentPosition *= (1.0 + sin(time * emitterPulseSpeed) * emitterPulse);\n        currentPosition *= emitterRadius;\n    }\n    else\n    {\n        if(vUv.x < stepX)\n        {\n            const vec3 emitterPos = vec3(0.0);\n            vec3 direction = emitterPos - currentPosition;\n            currentPosition += direction * distanceAttraction * length(direction) * speed;\n            currentPosition += curl(currentPosition * curlSize, time * curlTime, basePersistence + (1.0 - life) * dyingPersistence) * speed;\n            vec3 prev = texture2D(tPositions, vec2(vUv.x + stepX, vUv.y)).xyz;\n            currentPosition = mix(currentPosition, prev, step(1.0, abs(dot(normalize(currentPosition - prev), vec3(0.0, 1.0, 0.0)))));\n        }\n        else\n        {\n            currentPosition.xyz = texture2D(tPositions, vec2(vUv.x - stepX, vUv.y)).xyz;\n        }\n    }\n\n    currentPosition = mix(p.xyz, currentPosition, linesLazy);\n    gl_FragColor = vec4(currentPosition, 1.0);\n}\n"},21:function(n,e){n.exports="\nprecision highp float;\nprecision highp int;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\n\nuniform sampler2D tLifes;\nuniform float lifeReduction;\nuniform float lifeMultiplier;\nuniform float time;\n\nvarying vec2 vUv;\n\nvoid main()\n{\n    float stepX = 1.0 / resolution.x;\n\n    if(vUv.x < stepX)\n    {\n        vec4 l = texture2D(tLifes, vec2(0.0, vUv.y));\n        float life = l.y;\n        float total = l.z;\n        float percent = l.w;\n        life -= lifeReduction;\n        if(life < 0.0)\n        {\n            life = (0.5 + 0.5 * fract(l.x * 11.814 + time)) * lifeMultiplier;\n            total = life;\n            percent = 1.0;\n        }\n        else\n        {\n            percent = life / total;\n        }\n        gl_FragColor = vec4(l.x, life, total, percent);\n    }\n    else\n    {\n        gl_FragColor = vec4(1.0);\n    }\n}\n"},22:function(n,e){n.exports="precision highp float;\nprecision highp int;\nattribute vec2 uv;\nattribute vec3 position;\nattribute vec3 normal;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\n\nattribute float uvx;\nattribute float uvy;\n\nuniform sampler2D tLifes;\nuniform sampler2D tPositions;\nuniform float stepX;\nuniform float linesWidth;\nuniform vec3 lightPosition;\nuniform float lifeAppear;\n\nvarying vec4 vPos;\nvarying vec3 lPos;\nvarying float vLife;\n\nfloat parabola(float x, float k)\n{\n    return pow(4.0 * x * (1.0 - x), k);\n}\n\nfloat range(float oldValue, float oldMin, float oldMax, float newMin, float newMax) {\n    float oldRange = oldMax - oldMin;\n    float newRange = newMax - newMin;\n    return (((oldValue - oldMin) * newRange) / oldRange) + newMin;\n}\n\nvoid main()\n{\n    float life = texture2D(tLifes, vec2(0.0, uvy)).w;\n    vec4 current = texture2D(tPositions, vec2(uvx, uvy));\n    vec3 previous = texture2D(tPositions, vec2(uvx + stepX, uvy)).xyz;\n    vec3 next = texture2D(tPositions, vec2(uvx - stepX, uvy)).xyz;\n\n    vLife = life;\n\n    vec3 dir = normalize(next - previous);\n    vec3 binormal = normalize(cross(dir, vec3(0.0, 1.0, 0.0)));\n    vec3 normal = cross(binormal, dir);\n    mat3 TBN = mat3(dir, binormal, normal);\n    float l = clamp(range(life, 1.0, 0.0, 1.0 + lifeAppear, 0.0), 0.0, 1.0);\n    vec3 pos = current.xyz + (TBN * position) * linesWidth * parabola(l, 1.0);\n\n    lPos = (viewMatrix * vec4(lightPosition, 1.0)).xyz;\n    vPos = modelViewMatrix * vec4(pos, 1.0);\n    gl_Position = projectionMatrix * vPos;\n}\n"},23:function(n,e){n.exports="#extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\nprecision highp int;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\n\n/*\nuniform sampler2D shadowMap;\nuniform float shadowBias; //for non-fast shadow\nuniform float shadowRadius; //for non-fast shadow\nuniform vec2 shadowMapSize;\n\nvarying vec4 shadowCoord;\n\nconst float UnpackDownscale = 255.0 / 256.0; // 0..1 -> fraction (excluding 1)\nconst vec3 PackFactors = vec3(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0);\nconst vec4 UnpackFactors = UnpackDownscale / vec4(PackFactors, 1.0);\n\nfloat unpackRGBAToDepth(const in vec4 v) {\n    return dot(v, UnpackFactors);\n}\n\nfloat texture2DCompare(sampler2D depths, vec2 uv, float compare) {\n    return step(compare, unpackRGBAToDepth(texture2D(depths, uv)));\n}\n\nfloat getShadow()\n{\n    float shadow = 1.0;\n    vec4 sc = shadowCoord;\n\n    sc.xyz /= sc.w;\n    sc.z += shadowBias;\n\n    // if (something && something) breaks ATI OpenGL shader compiler\n    // if (all(something, something)) using this instead\n\n    bvec4 inFrustumVec = bvec4(sc.x >= 0.0, sc.x <= 1.0, sc.y >= 0.0, sc.y <= 1.0);\n    bool inFrustum = all(inFrustumVec);\n\n    bvec2 frustumTestVec = bvec2(inFrustum, sc.z <= 1.0);\n    bool frustumTest = all(frustumTestVec);\n\n    if(frustumTest)\n    {\n        vec2 texelSize = vec2(1.0) / shadowMapSize;\n\n        float dx0 = - texelSize.x * shadowRadius;\n        float dy0 = - texelSize.y * shadowRadius;\n        float dx1 = + texelSize.x * shadowRadius;\n        float dy1 = + texelSize.y * shadowRadius;\n\n        shadow = (\n            texture2DCompare(shadowMap, sc.xy + vec2(dx0, dy0), sc.z) +\n            texture2DCompare(shadowMap, sc.xy + vec2(0.0, dy0), sc.z) +\n            texture2DCompare(shadowMap, sc.xy + vec2(dx1, dy0), sc.z) +\n            texture2DCompare(shadowMap, sc.xy + vec2(dx0, 0.0), sc.z) +\n            texture2DCompare(shadowMap, sc.xy, sc.z) +\n            texture2DCompare(shadowMap, sc.xy + vec2(dx1, 0.0), sc.z) +\n            texture2DCompare(shadowMap, sc.xy + vec2(dx0, dy1), sc.z) +\n            texture2DCompare(shadowMap, sc.xy + vec2(0.0, dy1), sc.z) +\n            texture2DCompare(shadowMap, sc.xy + vec2(dx1, dy1), sc.z)\n       ) * (1.0 / 9.0);\n    }\n\n    return shadow;\n}\n\n//no smooth shadow\nfloat getFastShadow()\n{\n    vec4 sc = shadowCoord;\n    sc.xyz /= sc.w;\n    sc.z += shadowBias;\n\n    float shadow = 1.0 - texture2DCompare(shadowMap, sc.xy, sc.z);\n\n    //frustum check\n    shadow *= step(0.0, sc.x);\n    shadow *= 1.0 - step(1.0000001, sc.x);\n    shadow *= step(0.0, sc.y);\n    shadow *= 1.0 - step(1.0000001, sc.y);\n\n    return shadow;\n}\n*/\n\nuniform vec3 colorLines;\n\nuniform float hVariation;\nuniform float sVariation;\nuniform float vVariation;\n\nvarying float vLife;\nvarying vec4 vPos;\nvarying vec3 lPos;\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid main()\n{\n    vec3 normal = cross(normalize(dFdx(vPos.xyz)), normalize(dFdy(vPos.xyz)));\n    float shadow = max(0.0, dot(normalize(normal), normalize(lPos - vPos.xyz)));\n\n    vec3 color = colorLines;\n    color = rgb2hsv(color);\n    color.r += hVariation * vLife;\n    color.g += sVariation * vLife;\n    color.b += vVariation * vLife;\n    color = hsv2rgb(color);\n    color = color - shadow * 0.6;\n\n    gl_FragColor.rgb = color;\n    gl_FragColor.a = 1.0;\n}\n"},26:function(n,e){n.exports="precision highp float;\nprecision highp int;\nattribute vec2 uv;\nattribute vec3 position;\nattribute vec3 normal;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\n\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = vec4(position, 1.0);\n}\n"},27:function(n,e){n.exports="\nprecision highp float;\nprecision highp int;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\n\nvarying vec2 vUv;\n\nuniform vec3 colorBg1;\nuniform vec3 colorBg2;\n\n#ifndef PI\n    #define PI 3.141592653589793\n#endif\n\n#ifndef HALF_PI\n    #define HALF_PI 1.5707963267948966\n#endif\n\nfloat backInOut(float t) {\n    float f = t < 0.5\n    ? 2.0 * t\n    : 1.0 - (2.0 * t - 1.0);\n    float g = pow(f, 3.0) - f * sin(f * PI);\n    return t < 0.5\n    ? 0.5 * g\n    : 0.5 * (1.0 - g) + 0.5;\n}\nfloat backIn(float t) {\n    return pow(t, 3.0) - t * sin(t * PI);\n}\nfloat backOut(float t) {\n    float f = 1.0 - t;\n    return 1.0 - (pow(f, 3.0) - f * sin(f * PI));\n}\nfloat bounceOut(float t) {\n    const float a = 4.0 / 11.0;\n    const float b = 8.0 / 11.0;\n    const float c = 9.0 / 10.0;\n    const float ca = 4356.0 / 361.0;\n    const float cb = 35442.0 / 1805.0;\n    const float cc = 16061.0 / 1805.0;\n    float t2 = t * t;\n    return t < a\n    ? 7.5625 * t2\n    : t < b\n    ? 9.075 * t2 - 9.9 * t + 3.4\n    : t < c\n    ? ca * t2 - cb * t + cc\n    : 10.8 * t * t - 20.52 * t + 10.72;\n}\nfloat bounceIn(float t) {\n    return 1.0 - bounceOut(1.0 - t);\n}\nfloat bounceInOut(float t) {\n    return t < 0.5\n    ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\n    : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\nfloat circularInOut(float t) {\n    return t < 0.5\n    ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n    : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\nfloat circularIn(float t) {\n    return 1.0 - sqrt(1.0 - t * t);\n}\nfloat circularOut(float t) {\n    return sqrt((2.0 - t) * t);\n}\nfloat cubicInOut(float t) {\n    return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\nfloat cubicIn(float t) {\n    return t * t * t;\n}\nfloat cubicOut(float t) {\n    float f = t - 1.0;\n    return f * f * f + 1.0;\n}\nfloat elasticInOut(float t) {\n    return t < 0.5\n    ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0))\n    : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;\n}\nfloat elasticIn(float t) {\n    return sin(13.0 * t * HALF_PI) * pow(2.0, 10.0 * (t - 1.0));\n}\nfloat elasticOut(float t) {\n    return sin(-13.0 * (t + 1.0) * HALF_PI) * pow(2.0, -10.0 * t) + 1.0;\n}\nfloat expoInOut(float t) {\n    return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n    ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n    : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\nfloat expoIn(float t) {\n    return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\nfloat expoOut(float t) {\n    return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\nfloat linear(float t) {\n    return t;\n}\nfloat quadraticInOut(float t) {\n    float p = 2.0 * t * t;\n    return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\nfloat quadraticIn(float t) {\n    return t * t;\n}\nfloat quadraticOut(float t) {\n    return -t * (t - 2.0);\n}\nfloat quarticInOut(float t) {\n    return t < 0.5\n    ? +8.0 * pow(t, 4.0)\n    : -8.0 * pow(t - 1.0, 4.0) + 1.0;\n}\nfloat quarticIn(float t) {\n    return pow(t, 4.0);\n}\nfloat quarticOut(float t) {\n    return pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\n}\nfloat qinticInOut(float t) {\n    return t < 0.5\n    ? +16.0 * pow(t, 5.0)\n    : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;\n}\nfloat qinticIn(float t) {\n    return pow(t, 5.0);\n}\nfloat qinticOut(float t) {\n    return 1.0 - (pow(t - 1.0, 5.0));\n}\nfloat sineInOut(float t) {\n    return -0.5 * (cos(PI * t) - 1.0);\n}\nfloat sineIn(float t) {\n    return sin((t - 1.0) * HALF_PI) + 1.0;\n}\nfloat sineOut(float t) {\n    return sin(t * HALF_PI);\n}\n\nvoid main()\n{\n    gl_FragColor.rgb = mix(colorBg2, colorBg1, quadraticIn(vUv.y));\n    gl_FragColor.a = 1.0;\n}\n"},37:function(n,e,t){},39:function(n,e,t){},41:function(n,e,t){"use strict";t.r(e);var o=t(4),v=(t(37),t(0)),r=t(16),a=t(8),s=(t(38),t(32)),l={main:null,rootUrl:null,appData:null,client:{browser:"",device:"",lang:"",os:"",sizes:{width:window.innerWidth,height:window.innerHeight},mousePosition:{x:0,y:0}}},i=t(17),c=t.n(i),d=(t(39),t(9)),u=t(20),m=t.n(u),f=t(21),x=t.n(f),p=t(22),h=t.n(p),b=t(23),w=t.n(b);function y(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){var t=[],i=!0,o=!1,r=void 0;try{for(var a,s=n[Symbol.iterator]();!(i=(a=s.next()).done)&&(t.push(a.value),!e||t.length!==e);i=!0);}catch(n){o=!0,r=n}finally{try{i||null==s.return||s.return()}finally{if(o)throw r}}return t}(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function g(n,e){for(var t=0;t<e.length;t++){var i=e[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(n,i.key,i)}}var P=function(){function e(n){for(!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),this.mainUniforms=n.mainUniforms,this.linesNumber=n.linesNumber||1,this.textureWidth=Math.max(2,n.linesSegments||32),this.textureHeight=2;this.textureHeight<this.linesNumber;)this.textureHeight*=2;this._lineType=n.lineType||"DEFAULT",this._linesWidth=n.linesWidth||.5,this.renderer=n.renderer,this.computationFragment=m.a,this.computationDefines=n.computationDefines||{},this.computationUniforms=n.computationUniforms||{},this.meshUniforms=n.meshUniforms||{},this._createComputation(),this._createMesh()}var n,t,i;return n=e,(t=[{key:"_createComputation",value:function(){var o=this;this.computation=new d.a(this.textureWidth,this.textureHeight,this.renderer);for(var n=[],e=0;e<this.textureHeight;e++)for(var t=.1*(.5+.5*Math.random()),i=(Math.random()-.5)*Math.PI,r=Math.random()*Math.PI*2,a=t*Math.cos(r)*Math.cos(i),s=t*Math.sin(i),l=t*Math.sin(r)*Math.cos(i),c=0;c<this.textureWidth;c++)n.push(a,s,l,1);this.initialTexture=new v.n(new Float32Array(n),this.computation.sizeX,this.computation.sizeY,v.zb,v.x),this.initialTexture.needsUpdate=!0,this.lifeComputation=new d.a(2,this.textureHeight,this.renderer);for(var u=[],m=0;m<this.textureHeight;m++){var f=1.5*Math.random();u.push(f,-1,f,-1),u.push(0,0,0,1)}this.lifesTexture=new v.n(new Float32Array(u),2,this.lifeComputation.sizeY,v.zb,v.x),this.lifesTexture.needsUpdate=!0,this.positionsexture=this.computation.createTexture(),this.lifesVariable=this.lifeComputation.addVariable("tLifes",x.a,this.lifesTexture),this.positionsVariable=this.computation.addVariable("tPositions",this.computationFragment,this.positionsTexture),this.positionsVariable.material.uniforms.tInitial={value:this.initialTexture},this.positionsVariable.material.uniforms.tLifes={value:null},this.lifesVariable.material.uniforms.lifeReduction={value:this.mainUniforms.lifeReduction},this.lifesVariable.material.uniforms.lifeMultiplier={value:this.mainUniforms.lifeMultiplier},this.lifesVariable.material.uniforms.time={value:0},this.lifeComputation.setVariableDependencies(this.lifesVariable,[this.lifesVariable]),this.computation.setVariableDependencies(this.positionsVariable,[this.positionsVariable]),Object.entries(this.computationDefines).forEach(function(n){var e=y(n,2),t=e[0],i=e[1];o.positionsVariable.material.defines[t]=i}),Object.entries(this.computationUniforms).forEach(function(n){var e=y(n,2),t=e[0],i=e[1];o.positionsVariable.material.uniforms[t]=i});var p=this.lifeComputation.init(),h=this.computation.init();null===h&&null===p||console.error(h)}},{key:"_createMesh",value:function(){for(var n=1/this.textureWidth,e=1/this.textureHeight,t=this.horizontalPositions(),i=[],o=0;o<this.linesNumber;o++)i.push(o*e);var r=new v.h(2,2,2,this.textureWidth-1),a=new v.D;a.addAttribute("position",r.attributes.position),a.addAttribute("uv",r.attributes.uv),a.groups=r.groups,a.setIndex(r.index),a.addAttribute("uvx",new v.i(new Float32Array(t),1)),a.addAttribute("uvy",new v.C(new Float32Array(i),1,!1,1)),a.maxInstancedCount=this.linesNumber;var s={},l={tLifes:{value:null},tPositions:{value:null},stepX:{value:n},linesWidth:{value:this.mainUniforms.linesWidth},lifeAppear:{value:this.mainUniforms.lifeAppear},colorLines:{value:new v.m(this.mainUniforms.colorLines)},lightPosition:{value:this.mainUniforms.lightPosition},hVariation:{value:this.mainUniforms.hVariation},sVariation:{value:this.mainUniforms.sVariation},vVariation:{value:this.mainUniforms.vVariation}};this.meshColors&&(s.COLOR=!0,l.tColors={value:this.meshColors});var c=new v.Bb({vertexShader:h.a,fragmentShader:w.a,uniforms:l,defines:s});c.depthWrite=!1,c.depthTest=!1,Object.entries(this.meshUniforms).forEach(function(n){var e=y(n,2),t=e[0],i=e[1];c.uniforms[t]=i}),this.mesh=new v.ab(a,c),this.mesh.frustumCulled=!1}},{key:"horizontalPositions",value:function(){for(var n=[],e=1/this.textureWidth,t=0;t<4;t++)n.push(1-e);for(var i=0;i<4;i++)n.push(0);for(var o=0;o<this.textureWidth;o++)n.push(e*o);for(var r=0;r<this.textureWidth;r++)n.push(e*r);for(var a=0;a<this.textureWidth;a++)n.push(e*a);for(var s=0;s<this.textureWidth;s++)n.push(e*s);for(var l=0;l<this.textureWidth;l++)n.push(e*l);for(var c=0;c<this.textureWidth;c++)n.push(e*c);for(var u=this.textureWidth-1;0<=u;u--)n.push(e*u);for(var m=this.textureWidth-1;0<=m;m--)n.push(e*m);return n}},{key:"compute",value:function(){this.lifeComputation.compute(),this.positionsVariable.material.uniforms.tLifes.value=this.lifeComputation.getCurrentRenderTarget(this.lifesVariable).texture,this.computation.compute(),this.mesh.material.uniforms.tLifes.value=this.lifeComputation.getCurrentRenderTarget(this.lifesVariable).texture,this.mesh.material.uniforms.tPositions.value=this.computation.getCurrentRenderTarget(this.positionsVariable).texture}}])&&g(n.prototype,t),i&&g(n,i),e}(),z=t(24),M=t(33),C=(t(40),t(25)),U=t(26),S=t.n(U),V=t(27),L=t.n(V);function D(n,e){for(var t=0;t<e.length;t++){var i=e[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(n,i.key,i)}}var O=function(){function o(n,e,t,i){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,o),this.camera=n,this.renderer=e,this.mainUniforms=t,this.linesMesh=i,this.scene=new v.Eb,this.createBg(),this.scene.add(i),this.pass=new C.a(this.scene,this.camera),this.pass.setSize=function(n,e){},this.pass.renderToScreen=!1}var n,e,t;return n=o,(e=[{key:"createBg",value:function(){var n=new v.sb(2,2);this.bgMaterial=new v.Bb({uniforms:{colorBg1:{value:new v.m(this.mainUniforms.colorBg1)},colorBg2:{value:new v.m(this.mainUniforms.colorBg2)}},vertexShader:S.a,fragmentShader:L.a}),this.bgMaterial.depthTest=!1,this.bgMaterial.depthWrite=!1;var e=new v.ab(n,this.bgMaterial);e.frustumCulled=!1,e.renderOrder=-1,this.scene.add(e)}},{key:"addTime",value:function(){this.ballsMaterial&&(this.ballsMaterial.uniforms.time.value+=.02),this.starMaterial&&(this.starMaterial.uniforms.time.value-=.01),this.pointMaterial&&(this.pointMaterial.uniforms.time.value+=.01)}}])&&D(n.prototype,e),t&&D(n,t),o}(),I=t(28);var T=function n(e,t,i){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.pass=new I.a(new v.Ub(window.innerWidth,window.innerHeight),t,e,i),this.pass.renderToScreen=!0};function k(n){return(k="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}function F(n,e){for(var t=0;t<e.length;t++){var i=e[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(n,i.key,i)}}function j(n,e){return!e||"object"!==k(e)&&"function"!=typeof e?function(n){if(void 0!==n)return n;throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}(n):e}function A(n){return(A=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function _(n,e){return(_=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}var R=function(n){function o(n,e,t){var i;return function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,o),(i=j(this,A(o).call(this,{eventHub:{},store:l,router:{resize:function(){}},url:n,client:e,appData:t,appType:"DESKTOP",templateFunction:c.a}))).mainUniforms={linesNumber:1024,linesSegments:64,lightPosition:new v.Vb(-5,-5,0),colorBg1:"#120022",colorBg2:"#07000f",colorLines:"#e57afc",hVariation:-1,sVariation:.29,vVariation:.11,linesWidth:.045,linesLazy:.8,lifeReduction:.0034,lifeMultiplier:3,lifeAppear:.2,emitterRadius:10,emitterPulse:0,emitterPulseSpeed:20,speed:.18,distanceAttraction:.023,curlSize:.036,curlTime:6.3,basePersistence:.115,dyingPersistence:.5,bloomRadius:.1,bloomStr:.34,threshold:.47},i}var e,t,i;return function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),e&&_(n,e)}(o,s["a"]),e=o,(t=[{key:"setup",value:function(){var n=this;this.renderer=new v.ac({canvas:document.querySelector("canvas"),antialias:!1,transparent:!0}),this.renderer.setClearColor(this.mainUniforms.colorBg),this.camera=new v.rb(45,this.store.client.sizes.width/this.store.client.sizes.height,1e-4,1e3),this.camera.position.z=20,this.camera.position.y=0,this.resize(),this.controls=new z.a(this.camera),this.controls.target=new v.Vb(0,0,0),this.controls.enableDamping=!0,this.controls.dampingFactor=.15,this.boxLines=new P({mainUniforms:this.mainUniforms,linesNumber:this.mainUniforms.linesNumber,linesSegments:this.mainUniforms.linesSegments,renderer:this.renderer,linesWidth:this.mainUniforms.linesWidth,computationUniforms:{linesLazy:{value:this.mainUniforms.linesLazy},emitterPulse:{value:this.mainUniforms.emitterPulse},emitterPulseSpeed:{value:this.mainUniforms.emitterPulseSpeed},emitterRadius:{value:this.mainUniforms.emitterRadius},speed:{value:this.mainUniforms.speed},distanceAttraction:{value:this.mainUniforms.distanceAttraction},curlSize:{value:this.mainUniforms.curlSize},curlTime:{value:this.mainUniforms.curlTime},basePersistence:{value:this.mainUniforms.basePersistence},dyingPersistence:{value:this.mainUniforms.dyingPersistence},time:{value:0}}}),this.effectComposerScene=new M.a(this.renderer),this.passScene=new O(this.camera,this.renderer,this.mainUniforms,this.boxLines.mesh),this.passBloom=new T(this.mainUniforms.bloomRadius,this.mainUniforms.bloomStr,this.mainUniforms.threshold),this.effectComposerScene.addPass(this.passScene.pass),this.effectComposerScene.addPass(this.passBloom.pass),this.createGui(),Object(a.a)(-1,function(){n.controls.update(),n.boxLines.lifesVariable.material.uniforms.time.value+=.001,n.boxLines.positionsVariable.material.uniforms.time.value+=.001,n.boxLines.compute(),n.effectComposerScene.render()})}},{key:"createGui",value:function(){var e=this,n=new r.a,t=n.addFolder("Colors");t.closed=!1,t.addColor(this.mainUniforms,"colorBg1").onChange(function(n){e.passScene.bgMaterial.uniforms.colorBg1.value=new v.m(n)}),t.addColor(this.mainUniforms,"colorBg2").onChange(function(n){e.passScene.bgMaterial.uniforms.colorBg2.value=new v.m(n)}),t.addColor(this.mainUniforms,"colorLines").onChange(function(n){e.boxLines.mesh.material.uniforms.colorLines.value=new v.m(n)}),t.add(this.mainUniforms,"hVariation",-1,1).onChange(function(n){e.boxLines.mesh.material.uniforms.hVariation.value=n,console.log("h: "+n)}),t.add(this.mainUniforms,"sVariation",-1,1).onChange(function(n){e.boxLines.mesh.material.uniforms.sVariation.value=n,console.log("s: "+n)}),t.add(this.mainUniforms,"vVariation",-1,1).onChange(function(n){e.boxLines.mesh.material.uniforms.vVariation.value=n,console.log("v: "+n)});var i=n.addFolder("Lines");i.closed=!1,i.add(this.mainUniforms,"linesWidth",.01,.25).onChange(function(n){e.boxLines.mesh.material.uniforms.linesWidth.value=n}),i.add(this.mainUniforms,"linesLazy",.01,1).onChange(function(n){e.boxLines.positionsVariable.material.uniforms.linesLazy.value=n}),i.add(this.mainUniforms,"lifeReduction",.001,.03).onChange(function(n){e.boxLines.lifesVariable.material.uniforms.lifeReduction.value=n}),i.add(this.mainUniforms,"lifeMultiplier",.001,3).onChange(function(n){e.boxLines.lifesVariable.material.uniforms.lifeMultiplier.value=n}),i.add(this.mainUniforms,"lifeAppear",0,1).onChange(function(n){e.boxLines.mesh.material.uniforms.lifeAppear.value=n}),i.add(this.mainUniforms,"emitterRadius",0,200).onChange(function(n){e.boxLines.positionsVariable.material.uniforms.emitterRadius.value=n}),i.add(this.mainUniforms,"emitterPulse",0,5).onChange(function(n){e.boxLines.positionsVariable.material.uniforms.emitterPulse.value=n}),i.add(this.mainUniforms,"emitterPulseSpeed",0,200).onChange(function(n){e.boxLines.positionsVariable.material.uniforms.emitterPulseSpeed.value=n}),i.add(this.mainUniforms,"speed",0,1).onChange(function(n){e.boxLines.positionsVariable.material.uniforms.speed.value=n}),i.add(this.mainUniforms,"distanceAttraction",0,.1).onChange(function(n){e.boxLines.positionsVariable.material.uniforms.distanceAttraction.value=n,console.log("dying attraction: "+n)}),i.add(this.mainUniforms,"curlSize",0,.2).onChange(function(n){e.boxLines.positionsVariable.material.uniforms.curlSize.value=n}),i.add(this.mainUniforms,"curlTime",0,50).onChange(function(n){e.boxLines.positionsVariable.material.uniforms.curlTime.value=n}),i.add(this.mainUniforms,"basePersistence",0,1).onChange(function(n){e.boxLines.positionsVariable.material.uniforms.basePersistence.value=n,console.log("base: "+n)}),i.add(this.mainUniforms,"dyingPersistence",0,1).onChange(function(n){e.boxLines.positionsVariable.material.uniforms.dyingPersistence.value=n,console.log("dying: "+n)});var o=n.addFolder("Bloom");o.add(this.mainUniforms,"bloomRadius",.01,1).onChange(function(n){e.passBloom.pass.radius=n}),o.add(this.mainUniforms,"bloomStr",0,2).onChange(function(n){e.passBloom.pass.strength=n}),o.add(this.mainUniforms,"threshold",0,.75).onChange(function(n){e.passBloom.pass.threshold=n}),n.close()}},{key:"resize",value:function(n,e){this.renderer&&(this.camera.aspect=n/e,this.camera.updateProjectionMatrix(),this.renderer.setSize(n,e),this.effectComposerScene&&this.effectComposerScene.setSize(n,e))}}])&&F(e.prototype,t),i&&F(e,i),o}();function B(n,e){for(var t=0;t<e.length;t++){var i=e[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(n,i.key,i)}}var q=window.location.protocol+"//"+window.location.host,W={lang:"",os:"",device:"",browser:""},N=function(){function n(){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.detectOS(),this.detectDevice(),this.addClasses(),this.initApp(),this.sayHello()}var e,t,i;return e=n,(t=[{key:"detectOS",value:function(){!0===o.a.mac?W.os="mac":!0===o.a.ios?W.os="ios":W.os="windows"}},{key:"detectDevice",value:function(){if(o.a.mobile||o.a.tablet)W.device=o.a.mobile?"mobile":"tablet";else switch(W.device="desktop",o.a.name){case"Internet Explorer":W.browser="explorer";break;case"Microsoft Edge":W.browser="edge";break;case"Firefox":W.browser="firefox";break;case"Safari":W.browser="safari";break;default:W.browser="chrome"}}},{key:"addClasses",value:function(){var n=document.querySelector("html");for(var e in W)W[e]&&n.classList.add(W[e])}},{key:"initApp",value:function(n){new R(q,W,{}).render()}},{key:"sayHello",value:function(){if("Chrome"===o.a.name||"Firefox"===o.a.name){window.console.log.apply(console,["%c Developed by @vlucendo - http://vlucendo.com ","display: block; padding: 5px; background: #351330; line-height: 40px; color: #ffffff;"])}else window.console.log("Developed by @vlucendo - http://vlucendo.com")}}])&&B(e.prototype,t),i&&B(e,i),n}();"loading"!==document.readyState?new N:document.addEventListener("DOMContentLoaded",function(){new N},!1)}});